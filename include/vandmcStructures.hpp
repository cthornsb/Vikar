/** \file vandmcStructures.hpp
 * \brief Data structures for root output
 *
 * Special data types for Root output. Each individual processor which is
 * is used in the scan code should have its own Structure class. These classes
 * should contain simple C++ data types or vectors of simple C++ data types.
 * Vectors should be used for processors which are likely to have multiplicities
 * greater than one.

 * File automatically generated by
 *  RootClassBuilder (v. 1.0.4) on Wed May 23 14:34:46 2018
 *
 * \author C. Thornsbery
 * \date Sept. 25, 2014
 */

#ifndef ROOTDATAStructure_H
#define ROOTDATAStructure_H

#include "TObject.h"

#include <vector>

class Structure : public TObject {
  protected:
	std::string name; //! Structure name

  public:
	Structure(const std::string &name_=""){ name = name_; }

	virtual ~Structure(){}

	virtual void Zero(){}

	virtual Structure &operator = (const Structure &other_){ return Set(other_); }

	virtual Structure &Set(const Structure &other_){ return *this; }

	virtual Structure &Set(Structure *other_){ return *this; }

	ClassDef(Structure, 1); // Structure
};

class Trace : public TObject {
  protected:
	std::string name; //! Trace name

  public:
	std::vector<unsigned short> wave;
	unsigned int mult;

	Trace(const std::string &name_="");

	~Trace(){}

	void Zero();

	Trace &operator = (const Trace &other_){ return Set(other_); }

	Trace &Set(const Trace &other_);

	Trace &Set(Trace *other_);

	void Append(unsigned short *arr_, const size_t &size_);

	ClassDef(Trace, 1); // Trace
};

/** ReactionProductStructure
 * \brief Ejectile & recoil particle information
 *
 * Structure for storing information about the ejectile & recoil particles
 */
class ReactionProductStructure : public Structure {
  public:
	std::vector<double> hitX; /// The x-component of position of the detector hit in 3d space (m).
	std::vector<double> hitY; /// The y-component of position of the detector hit in 3d space (m).
	std::vector<double> hitZ; /// The z-component of position of the detector hit in 3d space (m).
	std::vector<double> hitR; /// The distance from the origin to the detector hit in 3d space (m).
	std::vector<double> hitTheta; /// The angle of the recoil particle about the vertical-axis (deg).
	std::vector<double> hitPhi; /// The angle of the recoil particle about the beam-axis (deg).
	std::vector<double> qdc; /// The energy of the particle calculated from the time-of-flight (MeV).
	std::vector<double> tof; /// The time-of-flight of the particle from the reaction point to the detector (ns).
	std::vector<double> energy; /// The energy of the particle after the reacting (MeV).
	std::vector<double> faceX; /// The x-component of the position of the detector hit on the face of the detector (m).
	std::vector<double> faceY; /// The y-component of the position of the detector hit on the face of the detector (m).
	std::vector<double> faceZ; /// The z-component of the position of the detector hit on the face of the detector (m).
	std::vector<int> loc; /// The location of the detector in the detector setup file.
	std::vector<bool> bg; /// Set to true if this is a background event.
	unsigned int mult; /// Multiplicity of recoil detector hits

	/// Default constructor
	ReactionProductStructure();

	/// Copy constructor
	ReactionProductStructure(const ReactionProductStructure &other_);

	/// Destructor. Does nothing
	~ReactionProductStructure(){}

	/// Push back with data
	void Append(const double &hitX_, const double &hitY_, const double &hitZ_, const double &hitR_, const double &hitTheta_, const double &hitPhi_, const double &qdc_, const double &tof_, const double &energy_, const double &faceX_, const double &faceY_, const double &faceZ_, const int &loc_, const bool &bg_);

	/// Zero the data Structure
	void Zero();

	/// Assignment operator
	ReactionProductStructure &operator = (const ReactionProductStructure &other_);

	/// Set all values to that of other_
	ReactionProductStructure &Set(const ReactionProductStructure &other_);

	/// Set all values to that of other_
	ReactionProductStructure &Set(ReactionProductStructure *other_);

	ClassDef(ReactionProductStructure, 1); // ReactionProduct
};

/** ReactionObjectStructure
 * \brief Reaction information
 *
 * Structure for storing information about the reaction
 */
class ReactionObjectStructure : public Structure {
  public:
	double energy; /// The input kinetic energy of the reaction (MeV).
	double Eeject; /// The outgoing ejectile particle kinetic energy (MeV).
	double Erecoil; /// The outgoing recoil particle kinetic energy (MeV).
	double comAngle; /// The center-of-mass angle of the reaction (deg).
	unsigned int state; /// The ID of the recoil excited state used for the reaction (0 is the g.s.).
	double reactX; /// The x-coordinate of the reaction point inside the target (m).
	double reactY; /// The y-coordinate of the reaction point inside the target (m).
	double reactZ; /// The z-coordinate of the reaction point inside the target (m).
	double trajectoryX; /// The x-coordinate of the trajectory of the beam particle just before the reaction.
	double trajectoryY; /// The y-coordinate of the trajectory of the beam particle just before the reaction.
	double trajectoryZ; /// The z-coordinate of the trajectory of the beam particle just before the reaction.

	/// Default constructor
	ReactionObjectStructure();

	/// Copy constructor
	ReactionObjectStructure(const ReactionObjectStructure &other_);

	/// Destructor. Does nothing
	~ReactionObjectStructure(){}

	/// Push back with data
	void Append(const double &energy_, const double &Eeject_, const double &Erecoil_, const double &comAngle_, const unsigned int &state_, const double &reactX_, const double &reactY_, const double &reactZ_, const double &trajectoryX_, const double &trajectoryY_, const double &trajectoryZ_);

	/// Zero the data Structure
	void Zero();

	/// Assignment operator
	ReactionObjectStructure &operator = (const ReactionObjectStructure &other_);

	/// Set all values to that of other_
	ReactionObjectStructure &Set(const ReactionObjectStructure &other_);

	/// Set all values to that of other_
	ReactionObjectStructure &Set(ReactionObjectStructure *other_);

	ClassDef(ReactionObjectStructure, 1); // ReactionObject
};

/** MonteCarloStructure
 * \brief Monte Carlo detector test information
 *
 * Structure for storing information about Monte Carlo hits on the detector setup
 */
class MonteCarloStructure : public Structure {
  public:
	std::vector<double> face1_hitX; /// X component of the entrance face intersect
	std::vector<double> face1_hitY; /// Y component of the entrance face intersect
	std::vector<double> face1_hitZ; /// Z component of the entrance face intersect
	std::vector<double> face2_hitX; /// X component of the exit face intersect
	std::vector<double> face2_hitY; /// Y component of the exit face intersect
	std::vector<double> face2_hitZ; /// Z component of the exit face intersect
	std::vector<double> hitTheta; /// Theta lab angle of the detector intersection
	std::vector<double> hitPhi; /// Phi lab angle of the detector intersection
	std::vector<int> face1_ID; /// ID of the face where the ray enters the detector
	std::vector<int> face2_ID; /// ID of the face where the ray exits the detector
	std::vector<int> location; /// The detector location in the detector setup file
	std::vector<int> type; /// Type of detector (0 == ejectile, 1 == recoil, 2 == both)
	unsigned int mult; /// Multiplicity of recoil detector hits

	/// Default constructor
	MonteCarloStructure();

	/// Copy constructor
	MonteCarloStructure(const MonteCarloStructure &other_);

	/// Destructor. Does nothing
	~MonteCarloStructure(){}

	/// Push back with data
	void Append(const double &face1_hitX_, const double &face1_hitY_, const double &face1_hitZ_, const double &face2_hitX_, const double &face2_hitY_, const double &face2_hitZ_, const double &hitTheta_, const double &hitPhi_, const int &face1_ID_, const int &face2_ID_, const int &location_, const int &type_);

	/// Zero the data Structure
	void Zero();

	/// Assignment operator
	MonteCarloStructure &operator = (const MonteCarloStructure &other_);

	/// Set all values to that of other_
	MonteCarloStructure &Set(const MonteCarloStructure &other_);

	/// Set all values to that of other_
	MonteCarloStructure &Set(MonteCarloStructure *other_);

	ClassDef(MonteCarloStructure, 1); // MonteCarlo
};

#endif
